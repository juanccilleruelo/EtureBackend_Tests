# Coding Style Guide - Delphi/Object Pascal (TMS Web Core)

This document defines the coding standards and conventions for this project. All AI-assisted code generation must follow these rules.

## Language and Comments

- **All comments must be written in English**, regardless of the developer's native language
- Use descriptive comments for complex logic or business rules
- Avoid redundant comments that simply restate what the code does

### Comment Styles

Different comment styles serve different purposes:

**Curly braces `{ }` - Permanent/Production comments:**
```pascal
{ Calculate the player's average score based on last 10 games }
AverageScore := CalculateAverage(PlayerStats);

{ TODO: Implement caching mechanism for better performance }
Result := FetchFromDatabase(Query);
```
- Use for documentation that is part of the final code
- Business logic explanations
- Important notes about implementation
- TODO items that should remain in production code

**Double slash `//` - Temporary/Developer comments:**
```pascal
// Testing this new approach - remove after validation
if NewAlgorithm then ProcessData;

// NOTE: This is a workaround until the API is fixed
TempValue := GetLegacyValue;

// ✅ CORRECT example for documentation
if Condition then Result := True;
```
- Use for temporary notes during development
- Comments that should be removed before production
- Notes to yourself or other developers during code review
- Examples and explanations in documentation (like this guide)

**Parenthesis-asterisk `(* *)` - Block comments:**
```pascal
(*
   This entire section is disabled for testing
   { Original permanent comment }
   // Temporary note
   if OldCondition then begin
      DoSomething;
   end;
*)
```
- Use when commenting out large blocks of code
- Useful when the block contains both `{}` and `//` comments
- Rarely used in production code

## Control Structure Formatting

### Begin Statement Placement
The `begin` keyword must **always** appear on the same line as the control statement:

```pascal
// ✅ CORRECT - Multiple statements
if Condition then begin
   Statement1;
   Statement2;
end;

// ✅ CORRECT - Single short statement on same line
if Condition then Result := True;

// ✅ CORRECT - Single short statement with else on same line
if Condition then Result := True 
else Result := False;

// ✅ CORRECT - Single long statement uses begin-end even if only one line
if VeryLongConditionThatRequiresMultipleChecks then begin
   ProcessComplexOperationWithLongMethodNameAndParameters(Param1, Param2, Param3);
end;

// ✅ CORRECT - Short then, long else
if Condition then Result := Value else begin
   PerformComplexCalculationWithMultipleSteps(Data);
end;

// ✅ CORRECT - Long then, short else
if Condition then begin
   ProcessLongOperationWithManyParameters(Value1, Value2, Value3);
end 
else Result := DefaultValue;

// ✅ CORRECT - Both branches use begin-end
if Condition then begin
   Statement1;
end else begin
   Statement2;
end;

// ✅ CORRECT - Multiple else-if branches
if Condition1 then begin
   Statement1;
end else 
if Condition2 then begin
   Statement2;
end 
else begin
   Statement3;
end;

for i := 0 to Count - 1 do begin
   ProcessItem(i);
end;

while Active do begin
   DoSomething;
end;

try
   RiskyOperation;
except
   on E: Exception do begin
      HandleError(E);
   end;
end;

// ❌ INCORRECT
if Condition then
begin
   Statement1;
end;
```

**Rule of thumb for if-then-else:**
- **Short single statement (< 80 chars)**: Write on same line without `begin-end`
- **Long single statement or multiple statements**: Use `begin-end` block
- **Mixed**: One branch can be inline while the other uses `begin-end` based on length
- **else keyword**: Usually appears on a new line after `end;`, can be on same line for very short inline statements

### Exception Handling
- Use specific exception types when possible
- `begin` after `except` clause with specific exception: `on E: Exception do begin`
- Simple exception handling without specific types can be on one line

## Variable Declarations

### Alignment
Variables must be vertically aligned with the first variable on the same line as `var`:

```pascal
// ✅ CORRECT
var NewField  :TField;
    DataSet   :TWebClientDataSet;
    ExceptMsg :string;
    i         :Integer;

// ✅ ALSO CORRECT (single variable)
var Result :TWebClientDataSet;

// ❌ INCORRECT
var
   NewField: TField;
   DataSet: TWebClientDataSet;
```

### Type Annotations
- Use space before and after the colon: `Variable :Type`
- Align colons vertically when declaring multiple variables
- Align type names vertically when declaring multiple variables

### Constants
Constants should be declared with proper alignment in the `const` section:

```pascal
const LOCAL_PATH          = '/schedule';
      TEST_CD_USER        = 'playerus';
      TEST_DS_CALENDAR    = 'Unit Test Calendar';
      UPDATED_DS_CALENDAR = 'Unit Test Updated Calendar';
      TEST_COLOR          = '#FF5733';
```

## Naming Conventions

### Variables and Fields
- Use descriptive PascalCase names
- Prefix parameters with `A`: `ADataSet`, `ADS_CALENDAR`, `AColor`
- Use meaningful names that reflect purpose
- Database field names typically use UPPERCASE_WITH_UNDERSCORES

### Methods and Functions
- Use PascalCase for method names
- Use descriptive verb-noun combinations: `CreateDataSet`, `FillUserData`, `HasTestCategory`
- Private helper methods should be clearly named
- Async methods should be marked with `[async]` attribute

### Constants
- Use UPPERCASE_WITH_UNDERSCORES for constants
- Group related constants together
- Prefix test constants appropriately: `TEST_`, `UPDATED_`

## Code Organization

### Unit Structure
```pascal
unit UnitName;

interface

uses
   // Group uses clauses logically
   WEBLib.UnitTesting.Classes,
   System.SysUtils, System.Classes, JS, Web,
   // ... more uses

type
{$M+}
   [TestFixture]
   TClassName = class(TObject)
   private
      // Constants first
      const CONSTANT_NAME = 'value';
   private
      // Private fields and methods
   published
      // Published test methods
   end;
{$M-}

implementation

uses
   // Implementation-specific uses
   
end.
```

### Method Organization
1. Field declarations
2. Local variable declarations with proper alignment
3. Method body with proper indentation

## Spacing and Indentation

### Indentation
- Use **3 spaces** for each indentation level (not tabs, not 2 or 4 spaces)
- Indent consistently within blocks

### Spacing
- Space after commas in parameter lists: `Method(Param1, Param2, Param3)`
- Space around operators: `i := 0`, `Count - 1`, `A + B`
- Space before opening parenthesis in control structures: `if (Condition) then`
- No space between method name and opening parenthesis: `Method(Param)`

### Line Breaks
- Keep lines reasonably short (ideally under 120 characters)
- Break long parameter lists across multiple lines with proper alignment:
```pascal
await(TDB.GetRow(LOCAL_PATH, 
                [['CD_USER'    , TEST_CD_USER],
                 ['DS_CALENDAR', ADS_CALENDAR]],
                DataSet, 
                '/getonecalendar'));
```

## Dataset Field Creation Pattern

When creating dataset fields, follow this consistent pattern:

```pascal
// For string fields
NewField := TStringField.Create(Result);
NewField.FieldName := 'FIELD_NAME';
NewField.Size := 50;
NewField.DataSet := Result;
Result.FieldDefs.Add(NewField.FieldName, ftString, NewField.Size);

// For integer/date/other fields
NewField := TIntegerField.Create(Result);
NewField.FieldName := 'FIELD_NAME';
NewField.DataSet := Result;
Result.FieldDefs.Add(NewField.FieldName, ftInteger, 0);
```

## Helper Procedures Pattern

Use nested procedures for repetitive field creation tasks:

```pascal
function TTestClass.CreateDataSet:TWebClientDataSet;
   procedure AddStringField(const AName :string; ASize :Integer);
   var Field :TStringField;
   begin
      Field := TStringField.Create(Result);
      Field.FieldName := AName;
      Field.Size := ASize;
      Field.DataSet := Result;
      Result.FieldDefs.Add(Field.FieldName, ftString, Field.Size);
   end;
begin
   inherited;
   Result := TWebClientDataSet.Create(nil);
   
   AddStringField('CD_USER', 50);
   AddStringField('EMAIL', 100);
   
   Result.Active := True;
end;
```

## Async/Await Pattern

- Mark async functions with `[async]` attribute
- Use `await()` for asynchronous operations:
```pascal
[async] function TTestClass.HasTestUser:Boolean;
var DataSet :TWebClientDataSet;
begin
   Result := False;
   DataSet := CreateDataSet;
   try
      await(TDB.GetRow(LOCAL_PATH, [['CD_USER', TEST_USER_CODE]], DataSet));
      Result := DataSet.RecordCount > 0;
   finally
      DataSet.Free;
   end;
end;
```

## Error Handling

Use try-except blocks with proper formatting:
```pascal
try
   RiskyOperation;
   ExceptMsg := 'ok';
except
   on E:Exception do ExceptMsg := E.Message;
end;
```

## Testing Conventions

- Use `[Test]` and `[async]` attributes for test methods
- Prefix test data with `TEST_` or `UPDATED_`
- Use descriptive test method names: `TestInsert`, `TestGetOne`, `TestUpdate`
- Follow Arrange-Act-Assert pattern implicitly

## General Best Practices

- Always free created objects in try-finally blocks when not using automatic memory management
- Use inherited calls where appropriate
- Keep methods focused and single-purpose
- Prefer explicit over implicit
- Use constants for magic strings and numbers
- Comment complex business logic, not obvious code

---

**Note**: These rules are mandatory for all code contributions, whether written by humans or AI assistants. Consistency is key to maintainable code.
